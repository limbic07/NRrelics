# 仓库清理功能完整实现计划

## 一、核心概念澄清

### 1.1 遗物状态（5种）
| 状态 | 代码 | 说明 |
|------|------|------|
| Light | Light | 亮态 - 可自由售出（未收藏、未装备） |
| Dark-FE | FE | 暗态 - 已收藏 + 已装备 |
| Dark-F | F | 暗态 - 已收藏（未装备） |
| Dark-E | E | 暗态 - 已装备（未收藏） |
| Dark-O | O | 暗态 - 官方遗物（不可售出） |

### 1.2 预设类型
| 类型 | 通用预设 | 专用预设 | 词条库来源 |
|------|----------|----------|------------|
| 普通白名单 | 1个 | 最多20个 | normal.txt |
| 深夜白名单 | 1个 | 最多20个 | deepnight_pos.txt |
| 深夜黑名单 | - | 1个 | deepnight_neg.txt |

### 1.3 词条结构
- **普通遗物**: 1-3条正面词条
- **深夜遗物**: 1-3条正面词条 + 0-3条负面词条（每条正面可能附带一条负面）

---

## 二、词条匹配逻辑（修正版）

### 2.1 匹配顺序（深夜模式）
```
1. 单正面词条检查 → 1条正面 → 直接不合格
2. 黑名单匹配 → 任意负面词条匹配 → 不合格
3. 白名单匹配（通用+所有专用）→ 合并计算匹配数
4. 合格判断 → 根据双有效/三有效设置
```

### 2.2 匹配顺序（普通模式）
```
1. 单正面词条检查 → 1条正面 → 直接不合格
2. 白名单匹配（通用+所有专用）→ 合并计算匹配数
3. 合格判断 → 根据双有效/三有效设置
```

### 2.3 白名单匹配核心逻辑（最终版）
```
假设：
- 通用预设包含词条: A, B, C, D, E
- 专用预设1包含: F, G, H
- 专用预设2包含: I, J, K

识别到的正面词条: A, G, I

匹配计算（只能是通用+专用X的组合）：
- 通用 + 专用1 = {A,B,C,D,E,F,G,H} → 匹配 A, G = 2条
- 通用 + 专用2 = {A,B,C,D,E,I,J,K} → 匹配 A, I = 2条

只要任一组合满足2有效/3有效，即为合格
注意：不能同时使用多个专用预设（如专用1+专用2）
```

### 2.4 白名单匹配算法
```python
def check_whitelist_match(
    pos_affixes: list,           # 识别到的正面词条
    general_preset: PresetConfig,  # 通用预设（可为None）
    dedicated_presets: list,      # 所有专用预设
    require_double: bool,          # True=2条, False=3条
) -> tuple[bool, int, str, list]:
    """
    检查白名单匹配

    匹配规则：只能是 通用+专用X 的组合，不能同时使用多个专用���设

    Returns:
        (qualified, matched_count, matched_preset_name, details)
    """
    required = 2 if require_double else 3

    # 只有一种方案：通用 + 每个专用逐一检查
    if general_preset:
        general_vocabs = set(general_preset["affixes"])

        for preset in dedicated_presets:
            combined = general_vocabs | set(preset["affixes"])
            count, details = count_matches(pos_affixes, combined)

            if count >= required:
                return True, count, f"{general_preset['name']}+{preset['name']}", details

    return False, 0, "", []
```

### 2.5 RapidFuzz性能
- **结论: rapidfuzz速度足够**
- 原因: 词条库总量约350条（normal）+ 50条（deepnight_pos）+ 30条（deepnight_neg）
- 单次匹配约350次模糊计算，耗时约1-5ms
- 每遗物最多4条词条匹配，总耗时可接受

---

## 三、数据结构设计

### 3.1 预设配置结构
```python
# 预设类型常量
PRESET_TYPE_NORMAL_WHITELIST = "normal_whitelist"
PRESET_TYPE_DEEPNIGHT_WHITELIST = "deepnight_whitelist"
PRESET_TYPE_DEEPNIGHT_BLACKLIST = "deepnight_blacklist"

# 预设配置
PresetConfig = {
    "id": str,                    # 预设唯一ID (UUID)
    "name": str,                   # 预设名称
    "type": str,                   # 预设类型
    "affixes": list[str],          # 该预设包含的词条列表
    "is_general": bool,            # 是否为通用预设（仅白名单有）
    "is_active": bool,             # 是否激活（用于专用预设）
}

# 预设文件结构 (data/presets.json)
{
    "version": "1.0",
    "normal_general": PresetConfig,     # 普通模式通用预设（固定）
    "deepnight_general": PresetConfig,  # 深夜模式通用预设（固定）
    "normal_dedicated": {               # 普通模式专用预设
        "uuid1": PresetConfig,
        "uuid2": PresetConfig,
        ...
    },
    "deepnight_whitelist_dedicated": {  # 深夜模式白名单专用预设
        "uuid1": PresetConfig,
        ...
    },
    "deepnight_blacklist": PresetConfig  # 深夜模式黑名单预设（固定1个）
}
```

### 3.2 词条识别结果
```python
# OCR识别结果
OCRResult = {
    "affixes": [
        {
            "text": str,           # 原始文本
            "cleaned_text": str,   # 清洗后文本
            "is_positive": bool,   # 是否正面词条
            "is_unknown": bool,    # 是否未知词条
        },
        ...
    ],
    "positive_count": int,         # 正面词条数量
    "negative_count": int,         # 负面词条数量
    "recognition_time": float,     # 识别耗时(ms)
}
```

### 3.3 词条匹配结果
```python
# 匹配结果
MatchResult = {
    "qualified": bool,            # 是否合格
    "reason": str,                # 合格/不合格原因
    "positive_matches": int,       # 正面词条匹配数
    "negative_matches": int,       # 负面词条匹配数
    "matched_affixes": list,       # 匹配的词条详情
    "details": list,              # 详细匹配信息
}
```

### 3.4 程序设置
```python
# page_repo设置
RepoSettings = {
    "cleaning_mode": str,         # "sell" | "favorite"
    "max_relics": int,            # 最大检测数量 (0=无限)
    "require_double_valid": bool, # 双有效模式 (True=2条匹配, False=3条匹配)
}

# page_settings设置
PageSettings = {
    "allow_operate_favorited": bool,   # 是否允许对被收藏遗物操作
    "game_window_title": str,           # 游戏窗口标题
}
```

---

## 四、模块划分

### 4.1 文件清单
| 文件 | 操作 | 说明 |
|------|------|------|
| `preset_manager.py` | 新增 | 预设管理器 |
| `repo_cleaner.py` | 新增 | 清理逻辑控制器 |
| `relic_detector.py` | 新增 | 遗物状态检测器 |
| `ocr_engine.py` | 新增 | 重构自cnocr_test.py |
| `ui/pages/page_repo.py` | 重构 | 仓库清理页面 |
| `ui/pages/page_settings.py` | 新增 | 设置页面 |
| `data/presets.json` | 新增 | 预设持久化文件 |

### 4.2 模块职责

#### preset_manager.py
- 预设的CRUD操作
- 预设持久化（JSON）
- 词条库加载
- 预设激活/禁用管理

#### repo_cleaner.py
- 主清理流程控制器
- 跳过决策逻辑
- 词条匹配逻辑
- 操作执行（售出/收藏）

#### relic_detector.py
- 遗物状态检测（Light/Dark）
- 状态细分检测（FE/F/E/O）
- 参照relic_detection_poc逻辑

#### ocr_engine.py
- CnOcr封装
- 词条清洗
- 词条纠错
- 正面/负面词条标记
- 词条计数

---

## 五、核心流程

### 5.1 主流程
```
用户配置：
  - 选择模式（普通/深夜）
  - 选择/创建预设
  - 选择清理模式（售出/收藏）
  - 设置参数（双有效/允许操作被收藏/最大数量）
  ↓
点击"开始"
  ↓
提示用户"请进入游戏遗物仪式界面"
  ↓
验证游戏界面
  ↓
调用 RepositoryFilter.apply_filter(mode)
  ↓
循环检测遗物：
  1. 状态检测 → Light/Dark + FE/F/E/O
  2. 跳过决策 → 根据清理模式、设置、状态决定
  3. 若不跳过 → OCR识别词条
  4. 词条匹配 → 合格/不合格
  5. 操作执行
  6. 按右方向键移动到下一遗物
  7. 计数检查（达到最大数量则停止）
  ↓
停止时执行：
  售出模式：按3售出 → 按F确认
  收藏模式：跳过
  ↓
清理完成，输出统计
```

### 5.2 跳过决策逻辑
```python
def should_skip_relic(
    relic_state: str,      # Light/FE/F/E/O
    cleaning_mode: str,     # "sell" | "favorite"
    allow_favorited: bool,  # 是否允许操作被收藏
) -> bool:
    """
    决定是否跳过该遗物

    Returns:
        True: 跳过
        False: 不跳过，需要处理
    """
    # 售出模式
    if cleaning_mode == "sell":
        if relic_state == "Light":
            return False  # Light直接处理
        elif relic_state in ["F", "FE"]:
            return not allow_favorited  # 已收藏时根据设置决定
        else:  # E, O
            return True  # 已装备或官方遗物跳过

    # 收藏模式
    elif cleaning_mode == "favorite":
        if relic_state == "Light":
            return False
        elif relic_state == "F":
            return True  # 已收藏的跳过
        elif relic_state == "FE":
            return not allow_favorited  # 已收藏+已装备
        else:  # E, O
            return False
```

### 5.3 词条匹配逻辑（最终版）
```python
def match_affixes(
    ocr_result: OCRResult,
    whitelist_presets: list[PresetConfig],  # 包含通用(is_general=True)和专用
    blacklist_presets: list[PresetConfig],   # 黑名单
    require_double: bool,                     # True=2条, False=3条
) -> MatchResult:
    """
    匹配词条（深夜模式）

    匹配顺序：
    1. 单正面词条 → 不合格
    2. 黑名单匹配 → 不合格
    3. 白名单匹配（通用 + 任一一套专用）→ 合格判断

    注意：只能是 通用+专用X 的组合，不能同时使用多个专用预设
    """
    pos_affixes = [a for a in ocr_result["affixes"] if a["is_positive"]]
    neg_affixes = [a for a in ocr_result["affixes"] if not a["is_positive"]]

    # 1. 单正面词条检查
    if len(pos_affixes) == 1:
        return MatchResult(
            qualified=False,
            reason="single_positive",
            positive_matches=0,
            negative_matches=0,
        )

    # 2. 黑名单匹配
    neg_matched_count = 0
    for neg in neg_affixes:
        for preset in blacklist_presets:
            for vocab in preset["affixes"]:
                if fuzz.ratio(neg["cleaned_text"], vocab) > 0.9:
                    neg_matched_count += 1
                    break
            if neg_matched_count > 0:
                break

    if neg_matched_count > 0:
        return MatchResult(
            qualified=False,
            reason="blacklist_match",
            positive_matches=0,
            negative_matches=neg_matched_count,
        )

    # 3. 白名单匹配（通用 + 任一一套专用）
    # 分离通用和专用预设
    general_preset = next((p for p in whitelist_presets if p.get("is_general")), None)
    dedicated_presets = [p for p in whitelist_presets if not p.get("is_general")]

    required_matches = 2 if require_double else 3
    best_match = {"count": 0, "preset": None, "details": []}

    # 只有一种方案：通用 + 每套专用逐一尝试
    if general_preset:
        general_vocabs = set(general_preset["affixes"])

        for preset in dedicated_presets:
            combined_vocabs = general_vocabs | set(preset["affixes"])
            count, details = _count_positive_matches(pos_affixes, combined_vocabs)

            if count > best_match["count"]:
                best_match = {
                    "count": count,
                    "preset": f"{general_preset['name']}+{preset['name']}",
                    "details": details,
                }

    # 4. 合格判断
    qualified = best_match["count"] >= required_matches

    return MatchResult(
        qualified=qualified,
        reason=f"{best_match['preset']}_match" if qualified else "insufficient_matches",
        positive_matches=best_match["count"],
        negative_matches=0,
        details=best_match["details"],
    )


def _count_positive_matches(
    pos_affixes: list,
    vocab_set: set[str]
) -> tuple[int, list]:
    """计算正面词条与词条集合的匹配数"""
    count = 0
    details = []

    for affix in pos_affixes:
        for vocab in vocab_set:
            similarity = fuzz.ratio(affix["cleaned_text"], vocab)
            if similarity > 0.9:
                count += 1
                details.append({
                    "affix": affix["cleaned_text"],
                    "matched_vocab": vocab,
                    "similarity": similarity,
                })
                break  # 每条词条只匹配一次

    return count, details
```

---

## 六、UI设计

### 6.1 page_repo.py 结构
```
RepoPage
├── 顶部工具栏
│   ├── 模式选择（普通/深夜）
│   ├── 清理模式（售出/收藏）
│   └── 最大检测数量输入
├── 左侧预设面板
│   ├── 通用预设（显示词条数量 + 编辑按钮）
│   ├── 专用预设列表（可创建/编辑/删除多个）
│   │   └── 每个：预设名称 + 词条数量 + 启用复选框 + 编辑按钮
│   └── 黑名单（深夜模式专属）
├── 右侧日志/仪表盘
│   ├── TabWidget
│   │   ├── 日志面板
│   │   └── 仪表盘（识别数/售出数/收藏数/处理中）
│   └── 控制按钮（开始/停止）
└── 底部状态栏
```

### 6.2 PresetEditDialog（新增）
```
PresetEditDialog
├── 预设名称输入
├── 词条选择列表（从词条库加载，多选，支持搜索）
│   └── 显示所有可用词条，用户勾选需要的词条
├── 确认/取消按钮
└── 词条搜索框（实时过滤）

说明：
- 通用预设和专用预设都通过此对话框编辑
- 词条来源都是词条库文件（normal.txt/deepnight_pos.txt/deepnight_neg.txt）
- 用户在对话框中勾选需要的词条，保存到预设配置中
```

### 6.3 page_settings.py 结构
```
PageSettings
├── 通用设置
│   ├── 游戏窗口标题设置
│   └── 是否允许对被收藏遗物操作
├── 匹配设置
│   └── 双有效模式开关（开启=2条匹配合格，否则3条）
└── 关于
    └── 版本信息
```

---

## 七、验证方案

### 7.1 单元测试
- 预设管理器CRUD操作
- 跳过决策逻辑
- 词条匹配逻辑
- OCR引擎基础功能

### 7.2 集成测试
- 完整清理流程
- UI交互（模式切换、预设编辑）
- 异常处理（用户取消、游戏窗口关闭）

### 7.3 性能测试
- 词条匹配速度（目标: <10ms/遗物）
- 整体流程速度（目标: <2s/遗物，包含OCR 0.7-1s）

注意：OCR识别速度约0.7-1s，这是CnOcr的正常性能，无需优化

---

## 八、注意事项

1. **预设数量限制**: 普通/深夜白名单各最多20个专用预设
2. **通用预设**: 每个模式各1个，不可删除
3. **预设词条来源**: 通用预设和专用预设的词条都来自词条库文件，用户通过UI勾选需要的词条
4. **词条清洗**: OCR结果和词条库使用相同的清洗规则
5. **rapidfuzz**: 使用fuzz.ratio，阈值90%
6. **线程安全**: 清理过程中禁止切换模式和编辑预设
7. **白名单匹配**: 只能是 通用+专用X 的组合，不能同时使用多个专用预设
